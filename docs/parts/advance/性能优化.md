## 前端性能优化

**内容上**

1. 减少http请求

   1. 文件合并（比如webpack将css和js各自打包成一个文件）
   2. 雪碧图（适合小而多的图标，比如导航）
   3. data_url（适合单个的小图标，比如logo，条纹（不断复用形成条纹背景）等）

2. 减少DNS查询次数

   增加主机数会提高并行下载的量，但是多次DNS查询耗时也较长，所以在这之间取个折中。

3. 延迟加载

   页面上的高级功能可以放到js中，js是延缓执行的，可以动态加载页面。比如图片的懒加载。

4. 提前加载

   比如谷歌，会将之后可能用到的logo、图标文件先下载下来。

   有条件的提前加载：或者雅虎根据你搜索的东西来下载可能用到的。

5. 减少DOM的数量。

**CSS**

1. link标签放在head中，因为这样可以显得页面加载的较快，能将已加载的html和css结合起来显示给用户。
2. 放在link标签中，避免使用@import，因为IE会将css文件放在页面底部。
3. 避免使用css动态表达式。（移动鼠标滚动屏幕网页绘制和大小改变的时候一直都在计算）

**js**

1. script标签放在底部，因为执行会阻塞html的渲染。（或者使用defer关键字，这样会在文档加载后执行）

2. css和js代码应该尽量精简。（有很多可以精简代码的工具）

3. 使用外部的css和js文件。

   1. 这些文件可以被浏览器缓存，从而在不同请求内容之间重用。
   2. 同时也减小了html的大小。
   3. 使用外部或内部也在于这些文件的重用率，只会访问一次的页面比如首页，用内部的会效率更高。

4. 减少DOM访问。

   1. 缓存已经访问过的元素。
   2. 离线更改再添到DOM树上。（比如react、vue）
   3. 尽量避免通过js修改layout。

5. 智能时间处理

   **尽量少的去触发事件，比如使用事件委托。**

**Cookie**

1. 减少cookie的大小。


## 高并发优化

**http并发数：**

![](https://pic2.zhimg.com/80/ea606d016e8ab77db9d8a8dfa5243a1b_hd.jpg)

增大后台的承受能力。

前端加强过滤能力。

1. **精简**
   1. 请求数量精简（去掉无用请求）。

      **合并**：（可以参考前端优化）

      1. 文件合并（比如webpack将css和js各自打包成一个文件）
      2. 雪碧图（适合小而多的图标，比如导航）
      3. data_url（适合单个的小图标，比如logo，条纹（不断复用形成条纹背景）等）
      4. html通过模板什么的合成一个。

      再将css、html、图片、js等合并到一起（模块化）（比如嵌入式js、css、base64等等），生成一个html文件。

      **图片服务器分离**

   2. 请求大小精简（去掉一些无用函数、代码）

      **压缩**： 

      1. 字符压缩：删除 Javascript 代码中所有注释、跳格符号、换行符号及无用的空格，从而压缩 JS 文件大小，优化页面加载速度。
      2. 变量混淆：经过编码将变量和函数原命名改为毫无意义的命名（如function(a,b,c,e,g)等），以防止他人窥视和窃取 Javascript 源代码，也有一定压缩效果。
      3. gzip。

2. **过滤**

   1. 缓存。（http cache、cookie、localstorage、sessionStorage、server worker、离线包）

      将原本要直接到后台的请求，通过缓存处获取达到过滤效果。

3. CDN

   其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地DNS的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。

**负载均衡**

### 内存和性能

**事件委托**

添加到页面上的事件处理程序数量直接关系到页面的整体运行性能。

每个函数都是对象，会占用内存，而且导致了DOM的访问次数增多，延迟交互就绪时间。

也可以考虑为 **document** 对象添加一个事件处理程序，用以处理页面上发生的某种
特定类型的事件。这样做与采取传统的做法相比具有如下优点。

- document 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序

（无需等待 DOMContentLoaded 或 load 事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。

-  在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 DOM 引用更少，所花的时间也更少。
-  整个页面占用的内存空间更少，能够提升整体性能。 

最适合采用事件委托技术的事件包括 **click、mousedown、mouseup、keydown、keyup 和 keypress。** 

**移除事件处理程序**

事件处理程序过多，会导致页面执行起来很慢。

事件委托可以限制处理程序的数量。

此外在不需要的时候移除事件处理程序，也可以解决这一问题。如果使用不当，可能内存中会留有空事件处理程序，影响内存和性能。

- 使用innerHTML替换页面中的绑定了事件处理程序的某一部分时，事件处理程序很有可能无法当做垃圾回收。最好先把赋值为null，释放内存，再通过innerHTML替换。

  ```js
  btn.onclick = null;
  ```

  或者使用removeChild()和 replaceChild()方法。

  事件委托也可以解决这个问题，因为不直接把事件绑在可能使用innerHTML的地方。

- 卸载页面（两个页面见切换，单击刷新按钮）时，没有清理干净事件处理程序，内存中滞留的对象数目就会增加，因为原来的事件处理程序占用的内存并没有被释放。

  可以通过onunload事件中处理程序移除所有的事件处理程序。事件委托更容易移除。